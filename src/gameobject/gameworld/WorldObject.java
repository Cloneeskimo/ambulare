package gameobject.gameworld;

import gameobject.GameObject;
import graphics.Material;
import graphics.Model;
import utils.AABB;
import utils.PhysicsEngine;

import java.util.ArrayList;
import java.util.List;

/**
 * Extends game objects to be more apt for world-type simulation. Namely, they have velocities and physics properties.
 * They use the physics engine to check for collisions and they have a set of unique physics properties to define
 * how the object reacts to collisions and is affected by the physical world. By default, the axis-aligned bounding
 * box generated by world objects and for collision detection is of the full width and height of the world object
 * itself, but this can be modified by calling setBoundingWidth() or setBoundingHeight()
 */
public class WorldObject extends GameObject {

    /**
     * Members
     */
    private List<WorldObject> collidables;        // a reference to the list of other objects to consider for collision
    protected float vx = 0f, vy = 0f;             // velocity of the world object
    private float bw = 1.0f, bh = 1.0f;           // proportion of the width/height considered for bounding boxes
    protected PhysicsEngine.PhysicsProperties pp; // properties that describe how this object interacts with physics

    /**
     * Constructor
     *
     * @param model    the model to use
     * @param material the material to use
     */
    public WorldObject(Model model, Material material) {
        super(model, material);
        this.collidables = new ArrayList<>();
        this.pp = new PhysicsEngine.PhysicsProperties();
    }

    /**
     * Updates the world object by applying velocity and checking for collisions in doing so
     *
     * @param interval the amount of time to account for
     */
    @Override
    public void update(float interval) {
        super.update(interval);
        if (!this.posAnimating()) { // if not in the middle of a positional animation
            // apply gravity
            this.vy = Math.max(this.vy - (this.pp.gravity * interval), PhysicsEngine.TERMINAL_VELOCITY);
            if (this.move(this.vx * interval, this.vy * interval)) // move according to velocity and interval
                this.onMove(); // call onMove() if an actual move occurred
        }
    }

    /**
     * World objects will not check for collisions during positional animations. This makes the item temporarily non-
     * collidable. However, after the destination point is reach, the world object is made collidable again. As such,
     * if the destination is not clear, collision will occur and objects may get knocked around after the positional
     * animation is finished. Once a positional animation is finished, velocity of the world object will be reset to 0
     *
     * @param interval the amount of time, in seconds, to account for
     */
    @Override
    protected void updatePosAnim(float interval) {
        this.posAnim.update(interval); // update animation
        this.getPhysicsProperties().collidable = false; // temporarily make not collidable
        // update position and rotation
        this.setX(this.posAnim.getX());
        this.setY(this.posAnim.getY());
        this.setRotRad(this.posAnim.getR());
        this.onMove(); // call onMove() to signify the object has moved
        if (this.posAnim.finished()) { // if animation is over
            this.setRotRad(this.posAnim.getFinalR()); // make sure at the correct ending rotation
            // set final position and rotation
            this.setX(this.posAnim.getFinalX());
            this.setY(this.posAnim.getFinalY());
            this.setRotRad(this.posAnim.getFinalR());
            this.getPhysicsProperties().collidable = true; // make collidable again
            this.posAnim = null; // delete the animation
            this.onMove(); // call onMove() to signify the object has moved
            // reset velocities
            this.setVX(0);
            this.setVY(0);
        }
    }

    /**
     * React to movements by using the physics engine to check for and react to collisions
     *
     * @param dx the x offset
     * @param dy the y offset
     * @return whether or not any movement actually occurred
     */
    public boolean move(float dx, float dy) {
        // delegate movement calculations to the physics engine
        return PhysicsEngine.move(this, dx, dy);
    }

    /**
     * Stops the world object by setting its velocities to zero and deleting its positional animation if the flag is set
     *
     * @param stopPosAnim whether or not to stop any positional animation that may be happening
     */
    public void stop(boolean stopPosAnim) {
        this.vx = this.vy = 0; // reset velocities
        if (stopPosAnim) this.posAnim = null; // delete positional animation if flag set
    }

    /**
     * Sets the list of collidables to check for collisions when moving
     *
     * @param collidables the list of collidables
     */
    public void setCollidables(List<WorldObject> collidables) {
        this.collidables = collidables;
    }

    /**
     * Updates the world object's horizontal (x) velocity
     *
     * @param vx the new horizontal velocity
     */
    public void setVX(float vx) {
        this.vx = vx;
    }

    /**
     * Updates the world object's vertical (y) velocity
     *
     * @param vy the new vertical velocity
     */
    public void setVY(float vy) {
        this.vy = vy;
    }

    /**
     * Updates the world object's horizontal (x) velocity by adding the given incremental change
     *
     * @param dvx the incremental change
     */
    public void incrementVX(float dvx) {
        this.vx += dvx;
    }

    /**
     * Updates the world object's vertical (y) velocity by adding the given incremental change
     *
     * @param dvy the incremental change
     */
    public void incrementVY(float dvy) {
        this.vy += dvy;
    }

    /**
     * Updates the world object's bounding width (see members)
     *
     * @param bw the new bounding width as a proportion
     */
    public void setBoundingWidth(float bw) {
        this.bw = bw;
    }

    /**
     * Updates the world object's bounding height (see members)
     *
     * @param bh the new bounding height as a proportion
     */
    public void setBoundingHeight(float bh) {
        this.bh = bh;
    }

    /**
     * @return the collidables to consider for collision for the world object
     */
    public List<WorldObject> getCollidables() {
        return this.collidables;
    }

    /**
     * @return the world object's horizontal (x) velocity
     */
    public float getVX() {
        return this.vx;
    }

    /**
     * @return the world object's vertical (y) velocity
     */
    public float getVY() {
        return this.vy;
    }

    /**
     * @return the axis-aligned bounding box corresponding to the world object. By default, this will return an AABB
     * with the full width and height of the object itself. Changing the world object's bounding width and bounding
     * height will make the AABB bigger/smaller. This may be useful if, for example, the object's texture doesn't fit
     * the entire model
     */
    public AABB getAABB() {
        return new AABB(this.getX(), this.getY(), this.getWidth() * this.bw, this.getHeight() * this.bh);
    }

    /**
     * @return the physics properties for the world object
     */
    public PhysicsEngine.PhysicsProperties getPhysicsProperties() {
        return this.pp;
    }
}

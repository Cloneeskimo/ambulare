package gameobject.gameworld;

import gameobject.GameObject;
import graphics.Material;
import graphics.Model;
import utils.AABB;
import utils.PhysicsEngine;

import java.util.ArrayList;
import java.util.List;

/**
 * Extends game objects to have physics properties. Namely, they are abled to perform physics. They use the physics
 * engine to check for calculations and they have a set of unique physics properties to define how the object reacts to
 * collisions and is affected by the physical world. By default, the axis-aligned bounding box generated by world
 * objects and for collision detection is of the full width and height of the world object itself.
 */
public class WorldObject extends GameObject {

    /**
     * Members
     */
    private List<WorldObject> collidables;      // a reference to the list of other objects to consider for collision
    private PhysicsEngine.PhysicsProperties pp; // the properties which describe how this object interacts with physics
    private float bw = 1.0f, bh = 1.0f;         // how much of the width/height should be considered for bounding boxes

    /**
     * Constructor
     * @param model the model to use
     * @param material the material to use
     */
    public WorldObject(Model model, Material material) {
        super(model, material);
        this.collidables = new ArrayList<>();
        this.pp = new PhysicsEngine.PhysicsProperties();
    }

    /**
     * Updates the world object by updating its normal game object properties and also applying gravity
     * @param interval the amount of time to account for
     */
    @Override
    public void update(float interval) {
        // apply gravity but do not go below terminal velocity
        this.vy = Math.max(this.vy - (this.pp.gravity * interval), PhysicsEngine.TERMINAL_VELOCITY);
        super.update(interval);
    }

    /**
     * React to movements by using the physics engine to check for and react to collisionss
     * @param dx the x offset
     * @param dy the y offset
     * @return whether or not any movement actually occurred
     */
    @Override
    public boolean move(float dx, float dy) {
        if (this.pp.collidable) return PhysicsEngine.move(this, dx, dy); // use physics engine
        else return super.move(dx, dy); // if collision for this object is off, handle movement normally
    }

    /**
     * Sets the list of collidables to check for collisions
     * @param collidables the list of collidables
     */
    public void setCollidables(List<WorldObject> collidables) {
        this.collidables = collidables;
    }

    /**
     * Updates the world object's bounding width (see members)
     * @param bw the new bounding width as a proportion
     */
    public void setBoundingWidth(float bw) {
        this.bw = bw;
    }

    /**
     * Updates the world object's bounding height (see members)
     * @param bh the new bounding height as a proportion
     */
    public void setBoundingHeight(float bh) {
        this.bh = bh;
    }

    /**
     * @return the axis-aligned bounding box corresponding to the world object. By default, this will return an AABB
     * with the full width and height of the object itself. Changing the world object's bounding width and bounding
     * height will make the AABB bigger/smaller. This may be useful if, for example, the object's texture doesn't fit
     * the entire model.
     */
    public AABB getAABB() {
        return new AABB(this.getX(), this.getY(), this.getWidth() * this.bw, this.getHeight() * this.bh);
    }

    /**
     * @return the collidables to consider for collision for the world object
     */
    public List<WorldObject> getCollidables() { return this.collidables; }

    /**
     * @return the physics settings for the object
     */
    public PhysicsEngine.PhysicsProperties getPhysicsProperties() { return this.pp; }
}
